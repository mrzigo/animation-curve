====== Работа с анимацией ======


Анимация это неотъемлемая часть современного сайта, большая часть анимации решается силами css/css+js. Рассмотрим простую анимацию CSS, а также сложные анимации, когда требуется применить WebGL, чтобы сложная анимация была по прежнему “легкой”, и не задерживала отрисовку (рендеринг) или пользовательский интерфейс.

==== Простая анимация ====



Речь идет о всей анимации, которая может и должна быть решена силами CSS, в некоторых случаях CSS + JS (когда подключается к анимации действия пользователя, например скроллинг)

К простым анимациям отнесу свойства CSS, поделив их на три группы, быстрые, медленные и совсем затратные.

Первая группа, сюда входят transform и opacity, у transform конкретно значения: translate, scale, rotate. Если изучить вопрос шире, то можно понять почему именно так, transform изначально позиционировалось как свойство работающее быстро, задействовав GPU, что хорошо сказывается на отзывчивости интерфейса пользователя.

Вторая группа, сюда вошли больше свойств: width, height, padding, margin, display, border, top, bottom, position, font, float, text-align, overflow, left, right, clear, white-space. Эти свойства затрагивают чаще всего поля ввода (input), но самое важно - затрагивают html/body что является затратной операцией и вся анимация автоматически становиться медленной и чем крупнее тем хуже итог. 

И последняя группа, свойства, затрагивающие перерисовку: color, border-style, visibility, background, text-decoration, background-position, background-repeat, outline, border-radius, box-shadow, background-size. Все что требуется перерисовать, автоматически считаем медленным и сильно нагружаемым процессор, а значит уменьшаем количество откликов интерфейса пользователя и это приводит к негативным последствиям.

Учитывать эти группы, это не значит отказываться от реализации анимации через эти свойства, есть одно хорошее правило, если анимацию можно решить силами css - лучше это сделать силами css, не нужно туда вмешивать JS. 

Пример отличной css анимации, которая справляется с задачей на ура:

  .move {
      position: absolute;
      bottom: 400px;
      transform: scale(10);
      animation: move 3s;
  }
  @keyframes move {
      0% {
          bottom: 200px;
          transform: scale(1);
      }
      100% {
          bottom: 400px;
          transform: scale(10);
      }
  }


Применив к html объекту класс move, css заставит объект с нижней точки в 200px перейти в 400px, а также изменить масштаб в 10 раз, все достаточно просто. Обратите внимание, что в .move должно быть описано уже итоговое состояние а не начальное.

CSS этим не ограничивается, советую воспользоваться поиском для просмотра всех возможностей css, в большинстве своем 90% анимации решается на css, исключением являются случаи, когда на поле слишком много элементов, или задача не специфична для css. 

Дальше рассмотрим варианты анимаций не специфичных для CSS, где явно требуется вмешательство не просто JS, а дополнительных возможностей браузера, таких как WebGL.


==== Как работать с кривыми Безье ====

1. Как работает canvas и что это такое, можно узнать тут: [[http://htmlbook.ru/html5/canvas]]

2. Что такое кривая Безье можно почитать тут: [[https://ru.wikipedia.org/wiki/Безье]]

Ниже на рисунке представлен общий вид кривой, по четырем опорным точкам, также кривая может быть задана по трем опорным точкам, по факту это когда точки А1 и B1 совпадают.
{{ :markup:снимок_экрана_от_2018-08-30_01-56-52.png?150 |}}

пример анимации с использованием кривых Безье можно посмотреть тут:

[[https://yadi.sk/i/VmjSviwq3YniaV]]

В примере сложная фигура разбита на 6 секторов кривых Безье, с течением времени на которой точки B и B1 перемещаются, меняя только координату x, нужно также отметить, что в анимации точки B и B1 имеют одинаковую координату x, тем самым, когда они смещаются и достигают тех же координат точек A (и A1) по оси OX и образуют вертикальную прямую, схематический пример можно посмотреть на втором рисунке ниже.

{{ :markup:снимок_экрана_от_2018-08-30_01-59-34.png?150 |}}

В анимации, вся фигура задана единым контуром, через привычный формат svg, где легко можно контролировать каждую координату опорной точки и менять некоторые из этих координат. 

В примере есть еще круги, которые смещаются при изменении координат точек B(B1), это обычные фигуры, раскрашенные разными цветами и завязанные на тот же параметр смещения что и опорные точки кривых Безье

Очень важно, если планируется интерактивное взаимодействие с канвас, то масштаб области должен оставаться идентичным (100%), иначе искажение затруднит определение пользовательских действий



Пример реализации через Fabric.js:
    // Создадим сцену, для работы с анимацией через фабрику:
    canvas = new Fabric.Canvas($(‘canvas’)[0], {
        width: 300,
        height: 300,
        interactive: false,
        renderOnAddRemove: false,
        selection: false
    });
  
    // зададим SVG кривую:
    const curveSVG = `M ${50} ${50} ` +
      `C ${50},${200} ${250},${100} ${250},${250} `
  
    // добавим кривую на сцену:
    curve = new Fabric.Path(curveSVG, {
        fill: 'transparent', 
        stroke: '#FF0000',
        objectCaching: false,
        selectable: false
    });
   canvas.add(curve)

//P.S. curveSVG специально построена через шаблонную строку, так как обычно вместо чисел используется выражение (умножение на коэффициент), что бы будущее изображение оставалось четким и не плыло от масштаба canvas области)
//

теперь на сцене есть кривая, с которой можно работать, менять её положение, вращать, менять масштаб и пр, спектр возможностей Fabric можно узнать в документации фабрики, нам интересно же изменять саму кривую, приступим:

    const nextPoint = 250 - 200 * delta;

где delta - это параметр от 0 до 1, именно он будет изменятся все время анимации и тем самым изменять будущие координаты. По данной формуле  nextPoint примет значение от 50 до 250, теперь осталось это значение передать в кривую на сцене и она сразу отобразит их

    curve.path[1][3] = nextPoint
    curve.path[1][5]  = nextPoint

готово, продолжая менять delta (стремить её к 1) будем менять координаты кривой, изменяя её форму. Что бы стало более ясно, вот так выглядят координаты точек:

    точка А:  [curve.path[0][1], curve.path[0][2] ]
    точка А1: [curve.path[1][1], curve.path[1][2] ]
    точка B1: [curve.path[1][3], curve.path[1][4] ]
    точка B:  [curve.path[1][5], curve.path[1][6] ]

чтобы понять почему так происходит, нужно изучить вопрос построения кривых(ломаных) в SVG.
Вот тут [[https://developer.mozilla.org/ru/docs/Web/SVG/Tutorial/Paths]] достаточно подробно раскрыт вопрос этого построения.


==== Проблемы с встраиванием на страницу которые могут возникнуть и как их решить ====

Если блок имеет абсолютное позиционирование, то проблемы будут точно наблюдаться в IE(Edge) и Safari, проблема IE решается правильным выставлением всех z-index элементов начиная от текущего canvas и заканчивая body, по всей ветке родителей элемента canvas, странный дефект, но лечиться достаточно просто. Для Safari эта проблема серьезнее, и частично решается за счет добавления к абсолютному элементу css свойства ‘-webkit-transform: translate3d(0, 0, 0);’ это помогает улучшить отрисовку элемента, но полностью баг не устраняется, отсюда как совет: по возможности избегать абсолютного позиционирования анимации.
Большой объем анимации, чем больше площадь canvas, тем выше потребление ресурсов, важно соблюдать баланс и не делать больших областей canvas.
Важно уметь отключать анимацию после завершения (если дизайн это предусматривает), что бы за пределами видимости блока не просчитывать лишние действия. Тут на помощь придет логика калбеков (пример в git) и технология браузера request animation frame подробнее тут [[https://learn.javascript.ru/js-animation]]


=== Рассмотрим пример на Pixi.js ===

Но уже с загрузкой текстур (файл png)

В основном принцип реализации через библиотеки всегда сохраняется, т.е. всегда приходится работать с объектом, который имеет координаты положения на так называемой сцене (сцена - это абстрактный элемент визуализации анимации, для упрощения работы всей анимации в целом, для программиста конечно же) в случае 2D анимации (которую мы будем рассматривать) сцена уходит на второй план и не требует детального рассмотрения, нам важны элементы видимые на canvas области. 

    const app = new PIXI.Application(width, height, {transparent: true});

app - объект анимации, который содержит canvas область в app.view, его требуется добавить в DOM для отображения.

    $(‘#my-element’).html(app.view);

Ранее я упоминал сцену - контейнер, в котором располагаются визуальные объекты, которые как то взаимодействуют между собой так как мы планируем использовать большое количество мелких частиц, PixiJS предоставляет специальный контейнер для работы с огромным количеством частиц, создадим его:


    const sprites = new PIXI.particles.ParticleContainer(count, {
        scale: true,
        position: true,
        rotation: true,
        uvs: true,
        alpha: true
    });

добавим его в app:

    app.stage.addChild(sprites);

Частицы задаются так:

    const particle = PIXI.Sprite.fromImage(‘/images/particle.png’);

Текстура подгружается автоматически, но если это большой фон или просто большой файл, то лучше предварительно его загрузить и использовать тут как готовую текстуру к работе, как это сделать, можно найти в документации к PixiJS, там это подробно расписано и есть примеры.

Теперь можно контролировать координаты/вращение и пр. параметры particle, не забываем про инициализирование всего что потребуется:

    particle.direction = Math.PI / 4;
    particle.delta = 0;
    particle.x = 0;
    particle.y = height;

затем следует добавить объект в сцену (контейнер объектов):

    sprites.addChild(particle);

sprites ожидает получение count элементов;

теперь инициализируем тик, который выполняется:

    app.ticker.add(() => {
        // тут выполняем требуемые расчеты с каждой частицей
        // например 
        particle.delta += 0.1;
        particle.x += Math.cos(particle.direction) * particle.delta;
        particle.y += -Math.sin(particle.direction) * particle.delta;
    })

Заставим эту частицу двигаться по прямой в направлении particle.direction, как изображено на рисунке

{{ :markup:снимок_экрана_от_2018-08-30_02-28-31.png?200 |}}

Начиная с этого момента ticker будет выполняться fps раз в секунду, перемещая точку от 0 до “бесконечности” (в рассмотренном тут примере)

==== Рассмотрим преимущества PixiJS ====

Простота исполнения сложной анимации, работаем только с логикой анимации, отрисовкой объектов занимается библиотека.

Возможность работать с большим количеством объектов (частиц), при этом практически не теряя в производительности (правда теряются некоторые функции, подробнее в документации PixiJS)

Библиотека хороша для сложной анимации, а также для реализации плавности работы анимации. Так же есть интерактивный режим работы объектов, что возможно положительно скажется на производительности страницы со сложными эффектами.

PixiJS лучше использовать для обработки сложных анимаций и/или использования большого количества частиц.

Из недостатков - те же, что описывал выше при работе с FabricJS, но если планируется использовать больше тысячи частиц, то однозначно нужно использовать PixiJS, шансы на плавность возрастают многократно, с чем не справляется даже фабрика, так как у фабрики нет “быстрой сцены” (ParticleContainer).

Обычно инструменты помогают решать какую то конкретную задачу, и если выбранный вами инструмент не справляется, то скорее всего инструмент неверный, как следствие слишком много проблем в реализации через этот инструмент.

**Рабочий пример, рассмотренный выше с кривыми, можно скачать/посмотреть тут**: [[https://github.com/mrzigo/animation-curve]]

в примере 5 анимаций, две рассмотренные (на fabricjs и на pixijs) и 3 дополнительных, все достаточно простые, но полезные для понимания возможностей и представления что можно сделать библиотеками, при этом не описывая много лишнего кода.


==== Заключение ====


В заключении хочется сказать, что избрав анимацию css, вам придется учитывать кроссплатформенность - это трудно, но реализуемо и не требует знать устройство воспроизведения вашей анимации, если избрать canvas-анимацию, то слабые устройства с ней не справятся, а к ним на сегодняшний момент относятся 60-70% всех мобильных гаджетов, и тут появляется дилемма, сделать “кривую” анимацию на сайте или сделать очень “тормознутую” или еще хуже - анимацию, убивающую сайт на устройстве совсем. 
В случае canvas-анимации, у вас не будет гарантии что она хорошо будет работать на всех десктоп клиентах, но в случае css, с выбранной поддержкой устройств - современный браузер с ней справится.

